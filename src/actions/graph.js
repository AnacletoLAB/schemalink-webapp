import {snapToNeighbourDistancesAndAngles} from "./geometricSnapping";
import {Guides} from "../graphics/Guides";
import {idsMatch, nextAvailableId} from "../model/Id";
import {Point} from "../model/Point";

export const createNode = () => (dispatch, getState) => {
  const { viewTransformation, applicationLayout } = getState()
  const windowSize = applicationLayout.windowSize
  const randomPosition = new Point(Math.random() * windowSize.width, Math.random() * windowSize.height)

  dispatch({
    category: 'GRAPH',
    type: 'CREATE_NODE',
    newNodeId: nextAvailableId(getState().graph.nodes),
    newNodePosition: viewTransformation.inverse(randomPosition),
    caption: ''
  })
}

export const createNodeAndRelationship = (sourceNodeId, targetNodePosition) => (dispatch, getState) => {
  dispatch({
    category: 'GRAPH',
    type: 'CREATE_NODE_AND_RELATIONSHIP',
    sourceNodeId,
    newRelationshipId: nextAvailableId(getState().graph.relationships),
    targetNodeId: nextAvailableId(getState().graph.nodes),
    targetNodePosition,
    caption: ''
  })
}

export const connectNodes = (sourceNodeId, targetNodeId) => (dispatch, getState) => {
  dispatch({
    category: 'GRAPH',
    type: 'CONNECT_NODES',
    sourceNodeId,
    newRelationshipId: nextAvailableId(getState().graph.relationships),
    targetNodeId
  })
}

export const tryMoveHandle = ({corner, oldMousePosition, newMousePosition}) => {
  return function (dispatch, getState) {
    const { graph, selection, viewTransformation, mouse } = getState()

    const vector = newMousePosition.vectorFrom(oldMousePosition).scale(1 / viewTransformation.scale)

    const selectedNodes = Object.keys(selection.selectedNodeIdMap)
      .map(nodeId => graph.nodes.find((node) => idsMatch(node.id, nodeId)))
    const dimensions = ['x', 'y']
    const ranges = {}
    dimensions.forEach(dimension => {
      const coordinates = selectedNodes.map(node => node.position[dimension])
      const min = Math.min(...coordinates)
      const max = Math.max(...coordinates)
      ranges[dimension] = {
        min,
        max,
        spread: max - min
      }
    })

    const coordinate = (position, dimension) => {
      const original = position[dimension]
      const range = ranges[dimension]
      switch (corner[dimension]) {
        case 'min':
          return range.max - (range.max - original) * (range.spread - vector['d' + dimension]) / range.spread
        case 'max':
          return range.min + (original - range.min) * (range.spread + vector['d' + dimension]) / range.spread
        default:
          return original
      }
    }

    const nodePositions = selectedNodes.map(node => {
      return {
        nodeId: node.id,
        position: new Point(
          coordinate(node.position, 'x'),
          coordinate(node.position, 'y')
        )
      }
    })

    dispatch(moveNodes(oldMousePosition, newMousePosition || mouse.mousePosition, nodePositions, new Guides()))
  }
}

export const tryMoveNode = ({ nodeId, oldMousePosition, newMousePosition, forcedNodePosition }) => {
  return function (dispatch, getState) {
    const { graph, viewTransformation, mouse } = getState()
    let naturalPosition
    const otherSelectedNodes = Object.keys(getState().selection.selectedNodeIdMap).filter((selectedNodeId) => selectedNodeId !== nodeId)
    const activelyMovedNode = graph.nodes.find((node) => idsMatch(node.id, nodeId))

    if (forcedNodePosition) {
      naturalPosition = forcedNodePosition
    } else {
      const vector = newMousePosition.vectorFrom(oldMousePosition).scale(1 / viewTransformation.scale)
      let currentPosition = getState().guides.naturalPosition || activelyMovedNode.position

      naturalPosition = currentPosition.translate(vector)
    }

    let snaps = snapToNeighbourDistancesAndAngles(graph, nodeId, naturalPosition, otherSelectedNodes)
    let guides = new Guides()
    let newPosition = naturalPosition
    if (snaps.snapped) {
      guides = new Guides(snaps.guidelines, naturalPosition)
      newPosition = snaps.snappedPosition
    }
    const delta = newPosition.vectorFrom(activelyMovedNode.position)
    const nodePositions = [{
      nodeId,
      position: newPosition
    }]
    otherSelectedNodes.forEach((otherNodeId) => {
      nodePositions.push({
        nodeId: otherNodeId,
        position: graph.nodes.find((node) => idsMatch(node.id, otherNodeId)).position.translate(delta)
      })
    })

    dispatch(moveNodes(oldMousePosition, newMousePosition || mouse.mousePosition, nodePositions, guides))
  }
}

export const moveNodes = (oldMousePosition, newMousePosition, nodePositions, guides, autoGenerated) => {
  return {
    category: 'GRAPH',
    type: 'MOVE_NODES',
    oldMousePosition,
    newMousePosition,
    nodePositions,
    guides,
    autoGenerated
  }
}

export const moveNodesEndDrag = (nodePositions) => {
  return {
    category: 'GRAPH',
    type: 'MOVE_NODES_END_DRAG',
    nodePositions
  }
}

export const setNodeCaption = (selection, caption) => ({
  category: 'GRAPH',
  type: 'SET_NODE_CAPTION',
  selection,
  caption
})

export const renameProperty = (selection, oldPropertyKey, newPropertyKey) => ({
  category: 'GRAPH',
  type: 'RENAME_PROPERTY',
  selection,
  oldPropertyKey,
  newPropertyKey
})

export const setProperty = (selection, key, value) => ({
  category: 'GRAPH',
  type: 'SET_PROPERTY',
  selection,
  key,
  value
})

export const setArrowsProperty = (selection, key, value) => ({
  category: 'GRAPH',
  type: 'SET_ARROWS_PROPERTY',
  selection,
  key,
  value
})

export const removeProperty = (selection, key) => ({
  category: 'GRAPH',
  type: 'REMOVE_PROPERTY',
  selection,
  key
})

export const removeArrowsProperty = (selection, key) => ({
  category: 'GRAPH',
  type: 'REMOVE_ARROWS_PROPERTY',
  selection,
  key
})


export const setRelationshipType = (selection, relationshipType) => ({
  category: 'GRAPH',
  type: 'SET_RELATIONSHIP_TYPE',
  selection,
  relationshipType
})

export const deleteNodesAndRelationships = (nodeIdMap, relationshipIdMap) => ({
  category: 'GRAPH',
  type: 'DELETE_NODES_AND_RELATIONSHIPS',
  nodeIdMap,
  relationshipIdMap
})

export const deleteSelection = () => {
  return function (dispatch, getState) {
    const selection = getState().selection
    const relationships = getState().graph.relationships

    const nodeIdMap = {...selection.selectedNodeIdMap}
    const relationshipIdMap = {...selection.selectedRelationshipIdMap}

    relationships.forEach(relationship => {
      if (!relationshipIdMap[relationship.id] && (nodeIdMap[relationship.fromId] || nodeIdMap[relationship.toId])) {
        relationshipIdMap[relationship.id] = true
      }
    })

    dispatch(deleteNodesAndRelationships(nodeIdMap, relationshipIdMap))
  }
}